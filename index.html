<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Rubik's Tangle solver</title>
        <script src="js/tangle.js"></script> 
        <script>
             
            if (!window.Worker) { alert('Please use a modern browser which supports HTML5 Web Workers'); } 

            function createTiles() {
                var tiles = new Array();
                var colours = ['b', 'g', 'r', 'y'];

                for (var a in colours)
                for (var b in colours)
                for (var c in colours)
                for (var d in colours) {
                    if (a == b || a == c || a == d || b == c || b == d || c == d) {
                        continue;
                    }
                    tiles.push([colours[a], colours[b], colours[c], colours[d]].join(''));
                }
                // 25th tile is a duplicate
                tiles.push('ygrb');
                return tiles;
            }
            
            var tileDivs = new Array();
            
            function createTileDiv(tileDefinition) {
                var tileDiv = document.createElement('div');
                tileDiv.className = 'tile';
                tileDiv.style.backgroundImage = 'url(img/' + tileDefinition + '.png)';
                return tileDiv;
            }
            
            function showAvailableTiles() {
                var tiles = createTiles();
                var availableTilesDiv = document.getElementById('availableTiles');
                
                for (var i = 0; i < tiles.length; i++) {
                    availableTilesDiv.appendChild(createTileDiv(tiles[i]));
                }
            }
            
            var Counter = function(onChanged) {
                var self = this;
                self.count = 0;
                
                self.increment = function() {
                    self.count++;
                    if (onChanged) {
                        onChanged(self.count);
                    }
                }
            }
            
            function updateCounter(count) {
                if (count % 100 == 0) {
                    counterP.innerText = count;
                }
            }
            
            var counter = new Counter(updateCounter);
            
            function placeTile(x, y, definition, rotation) {
                tileDivs[y][x].style.backgroundImage = 'url(img/' + definition + '.png)';
                tileDivs[y][x].style.transform = getTransformStyleForRotation(rotation);
                counter.increment();
            }
            
            function getTransformStyleForRotation(rotation) {
                switch (rotation) {
                    case 0: return '';
                    case 1: return 'rotate(90deg)';
                    case 2: return 'rotate(180deg)';
                    case 3: return 'rotate(270deg)';
                }
            }
            
            function removeTile(x, y) {
                tileDivs[y][x].style.backgroundImage = '';
            }
            

            function go() {
                counterP = document.getElementById('counter');
                var solutionTable = document.getElementById('solution');
                for (var y = 0; y < 5; y++) {
                    var tr = document.createElement('tr');
                    var tiles = new Array();
                    for (var x = 0; x < 5; x++) {
                        var td = document.createElement('td');
                        var tileDiv = document.createElement('div');
                        tileDiv.className = 'tile';
                        td.appendChild(tileDiv);
                        tiles.push(tileDiv);
                        tr.appendChild(td);
                    }
                    tileDivs.push(tiles);
                    solutionTable.appendChild(tr);
                }
                
                var tangleWorker = new Worker("js/tangleworker.js");
                tangleWorker.onmessage = OnTangleSolverWorkerMessage; 
                tangleWorker.postMessage(createTiles());
            }
            
            function OnTangleSolverWorkerMessage(evt) {
                switch (evt.data.event) {
                    case 'onTilePlaced': {
                        placeTile(evt.data.position.x, evt.data.position.y, evt.data.tile.definition, evt.data.tile.rotation);
                        return;
                    }
                    case 'onTileRemoved': {
                        removeTile(evt.data.position.x, evt.data.position.y);
                        return;
                    }
                }
            }
            
        </script>
        <style>
            #availableTiles div { margin: 0 5px 5px 0; }
            #solution {
                width: 260px;
                border-spacing: 0;
            }
            #solution td { padding: 0; }
            .tile-container .tile {
                float: left;
            }
            .tile-container:after {
                content: '';
                display: block;
                clear: both;
            }
            .tile {
                width: 52px;
                height: 52px;
            }
        </style>
    </head>
    
    <body onload="showAvailableTiles()">
        <h1>Rubik's Tangle solver</h1>
    
        <h2>Available tiles</h2>
        
        <div id="availableTiles" class="tile-container"></div>
        
        <button onclick="go()">Go</button>
        
        <table id="solution"></table>
        
        <p id="counter"></p>
        
    </body>

</html>